describe("general categories", function()
	local general_category = require "unistring.ctype.general_category"
	it("has working .is()", function()
		assert.same(true, general_category.is(string.byte("f"), general_category.byname("LETTER")))
		assert.same(true, general_category.is(string.byte("F"), general_category.byname("LETTER")))
		assert.same(false, general_category.is(string.byte("1"), general_category.byname("LETTER")))
		assert.same(false, general_category.is(string.byte("-"), general_category.byname("LETTER")))
	end)
	it("can be combined with 'or'", function()
		local alnum = general_category.Or(general_category.byname("UPPERCASE_LETTER"), general_category.byname("LOWERCASE_LETTER"), general_category.byname("NUMBER"))
		assert.same(true, general_category.is(string.byte("f"), alnum))
		assert.same(true, general_category.is(string.byte("F"), alnum))
		assert.same(true, general_category.is(string.byte("1"), alnum))
		assert.same(false, general_category.is(string.byte("-"), alnum))
	end)
	it("can be combined with 'and'", function()
		local upper = general_category.And(general_category.byname("LETTER"), general_category.byname("UPPERCASE_LETTER"))
		assert.same(false, general_category.is(string.byte("f"), upper))
		assert.same(true, general_category.is(string.byte("F"), upper))
		assert.same(false, general_category.is(string.byte("1"), upper))
		assert.same(false, general_category.is(string.byte("-"), upper))
	end)
	it("has a working :name()", function()
		assert.same("L", general_category.byname("L"):name())
		assert.same("L", general_category.byname("LETTER"):name())
	end)
	it("has working .of()", function()
		assert.same("Ll", general_category.of(string.byte("f")):name())
	end)
end)
describe("bidi categories", function()
	local bidi_category = require "unistring.ctype.bidi_category"
	it("has working .is()", function()
		assert.same(true, bidi_category.is(string.byte("f"), bidi_category.byname("L")))
		assert.same(true, bidi_category.is(string.byte("F"), bidi_category.byname("L")))
		assert.same(false, bidi_category.is(string.byte("1"), bidi_category.byname("L")))
		assert.same(false, bidi_category.is(string.byte("-"), bidi_category.byname("L")))
	end)
	it("has a working .name()", function()
		assert.same("L", bidi_category.name(bidi_category.byname("L")))
	end)
	it("has working .of()", function()
		assert.same("L", bidi_category.name(bidi_category.of(string.byte("f"))))
	end)
end)
describe("wordbreak property", function()
	local unictype = require "unistring.ctype"
	it("has working .of()", function()
		assert.same(unictype.WBP.ALETTER, unictype.wordbreak_property(string.byte("f")))
	end)
end)
describe("number related ctype functions", function()
	local unictype = require "unistring.ctype"
	it("decimal_value", function()
		assert.same(1, unictype.decimal_value(string.byte("1")))
		assert.same(nil, unictype.decimal_value(string.byte("a")))
	end)
	it("digit_value", function()
		assert.same(1, unictype.digit_value(string.byte("1")))
		assert.same(nil, unictype.digit_value(string.byte("a")))
	end)
	it("numeric_value", function()
		assert.same({1,1}, {unictype.numeric_value(string.byte("1"))})
		assert.same(nil, unictype.numeric_value(string.byte("a")))
	end)
end)
describe("mirror_char", function()
	local unictype = require "unistring.ctype"
	it("works", function()
		assert.same({false, string.byte("f")}, {unictype.mirror_char(string.byte("f"))})
		assert.same({true, string.byte("<")}, {unictype.mirror_char(string.byte(">"))})
	end)
end)
describe("property", function()
	local property = require "unistring.ctype.property"
	it("has working .is()", function()
		assert.same(true, property.is(string.byte("f"), property.byname("ALPHABETIC")))
		assert.same(true, property.is(string.byte("F"), property.byname("ALPHABETIC")))
		assert.same(false, property.is(string.byte("1"), property.byname("ALPHABETIC")))
		assert.same(false, property.is(string.byte("-"), property.byname("ALPHABETIC")))
	end)
	it("has a working .is_valid()", function()
		assert.truthy(property.is_valid(property.byname("ALPHABETIC")))
	end)
end)
